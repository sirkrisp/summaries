## Hit

#### Problem
Check whether ray intersect line

#### Difficulties
End early to minimize number of intersection tests

#### Techniques
CGAL, Exact Constructions, Intersections

#### Solution

```c++ linenums="1"
#include <iostream> // We will use C++ input/output via streams
#include <CGAL/Exact_predicates_exact_constructions_kernel.h>

typedef CGAL::Exact_predicates_exact_constructions_kernel K;
typedef K::Point_2 P;
typedef K::Segment_2 L;
typedef K::Ray_2 R;

bool testcase() {
    int n; std::cin >> n; // Read the number of integers to follow
    if(n == 0) return false;
    long x, y, a, b;
    std::cin >> x >> y >> a >> b;
    P p1(x, y);
    P p2(a, b);
    R ray(p1, p2);
    
    long r, s, t, u;
    bool hit = false;
    for(int i = 0; i < n; ++i){
      std::cin >> r >> s >> t >> u;
      if(!hit){
        p1 = P(r, s);
        p2 = P(t, u);
        L l(p1, p2);
        if (CGAL::do_intersect(l, ray))
          hit = true;
      }
    }
    
    if(hit)
      std::cout << "yes" << std::endl;
    else
      std::cout << "no" << std::endl;
    return true;
}

int main() {
    std::ios_base::sync_with_stdio(false); // Always!
    while(testcase()); // Solve a particular test case
}
```


## First Hit

#### Problem
Determine the intersection point at which a ray hits one of $n$ segments first.

#### Difficulties
When to use inexact / exact kernel

#### Techniques
Clipping, Intersections, CGAL, Exact Kernel

#### Solution
From sample solution. **Clip** the ray to minimize the number of intersection constructions (note that checking for intersection is a *predicate* operation - finite number of outputs). If we assume that the input data is random, clipping the ray reduces the expected number of constructions to $O(\log n)$. To see this, let us define for each iteration $i$ the random variable $x_i$ which is $1$ when segment $s_i$ intersects the clipped ray $r_i$ and $0$ otherwise. $x_i$ is $1$ iff the distance $d_i < d_j, \, j < i$. The expected value for this event is 

$$E[x_i = 1] = 1 \cdot p(x_i = 1) = \frac{i!}{(i+1)!} = \frac{1}{(i+1)}$$

Therefore, the total expected value for the number of intersection events is:

$$E \left[\sum_{i=0}^{n-1}{x_i = 1} \right] = \sum_{i=1}^n \frac{1}{i} = O(\log n)$$

```c++ linenums="1"
#include <CGAL/Exact_predicates_exact_constructions_kernel.h> #include <vector>
#include <algorithm>
#include <type_traits>
#include <stdexcept>
typedef CGAL::Exact_predicates_exact_constructions_kernel K;
typedef std::result_of<K::Intersect_2(K::Ray_2, K::Segment_2)>::type IT;
// round down to next double (as defined in the tutorial)
double floor_to_double(const K::FT &x)
{
	double a = std::floor(CGAL::to_double(x));
	while (a > x)
		a -= 1;
	while (a + 1 <= x)
		a += 1;
	return a;
}
// clip/set target of s to o
void shorten_segment(K::Segment_2 &s, const IT &o)
{
	if (const K::Point_2 *p = boost::get<K::Point_2>(&*o))
		s = K::Segment_2(s.source(), *p);
	else if (const K::Segment_2 *t = boost::get<K::Segment_2>(&*o))
		// select endpoint of *t closer to s.source()
		if (CGAL::collinear_are_ordered_along_line(s.source(), t->source(), t->target()))
			s = K::Segment_2(s.source(), t->source());
		else
			s = K::Segment_2(s.source(), t->target());
	else
		throw std::runtime_error("Strange segment intersection.");
}
void find_hit(std::size_t n)
{
	// read input
	long x1, y1, x2, y2;
	std::cin >> x1 >> y1 >> x2 >> y2;
	K::Ray_2 r(K::Point_2(x1, y1), K::Point_2(x2, y2));
	std::vector<K::Segment_2> segs;
	segs.reserve(n);
	for (std::size_t i = 0; i < n; ++i)
	{
		std::cin >> x1 >> y1 >> x2 >> y2;
		segs.push_back(K::Segment_2(K::Point_2(x1, y1), K::Point_2(x2, y2)));
	}
	std::random_shuffle(segs.begin(), segs.end());
	// clip the ray at each segment hit (cuts down on the number of intersection // points to be constructed: for a uniformly random order of segments, the // expected number of constructions is logarithmic in the number of segments // that intersect the initial ray.)
	K::Segment_2 rc(r.source(), r.point(1));
	// find some segment hit by r
	std::size_t i = 0;
	for (; i < n; ++i)
		if (CGAL::do_intersect(segs[i], r))
		{
			shorten_segment(rc, CGAL::intersection(segs[i], r));
			break;
		}
	if (i == n)
	{
		std::cout << "no\n";
		return;
	} // check remaining segments against rc
	while (++i < n)
		if (CGAL::do_intersect(segs[i], rc))
			shorten_segment(rc, CGAL::intersection(segs[i], r)); // not rc!
	std::cout << floor_to_double(rc.target().x()) << " " << floor_to_double(rc.target().y()) << "\n";
}
int main()
{
	std::ios_base::sync_with_stdio(false);
	std::cout << std::setiosflags(std::ios::fixed) << std::setprecision(0);
	for (std::size_t n; std::cin >> n && n > 0;)
		find_hit(n);
}
```


## Antenna

#### Problem
Find minimum enclosing circle 

#### Difficulties
Kernel with sqrt too slow

#### Techniques
Min_Circle_2, Ceil to double

#### Solution

```c++ linenums="1"

```


## Hiking Maps

#### Problem

#### Difficulties

#### Techniques

#### Solution